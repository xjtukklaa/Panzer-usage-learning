\subsubsection{Tutorial Step 3 - GEMM and Euler Flow}
这个案例主要是使用GEMM算法快速计算矩阵和矩阵的乘法，主要看不懂的点集中在模板化，和一堆
这个作者自己定义的类型上面，之前用Trilinos的时候也是差不多这样坐牢，纯纯的坐牢，想不做
是不可能的，感觉不如Petsc使用起来上手。其次就是CRS矩阵的具体实现过程，如果有兴趣可以参考
注释看一下，sandia实验室的代码都一个样子，封装完成后使用List进行具体实现。

虽然到现在我还是对Kokkos这东西一脸懵逼，但还是要挖个大坑，计划搞明白
这个使用Kokkos，FVM和DG计算时变欧拉流的代码，目前已经能够完全跑起来，使用paraview进行
后处理，可能得补以下FVM的东西，DG之前就看过。在这个过程中连带这学一下Kokkos的稀疏矩阵和
一些抽象的simd指令。

\begin{lstlisting}
#include <limits>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <Kokkos_Core.hpp>
#include <KokkosSparse_CrsMatrix.hpp>
#include <KokkosSparse_spgemm.hpp>

void checkSizes(int &N)
{
    // If N is undefined, set it to 2^10 = 1024.
    if (N == -1)
    N = 1024;

    printf("  Number of Rows N = %d, Number of Cols N = %d, Total nnz = %d\n", N, N, 2 + 3 * (N - 2) + 2);

    // Check sizes.
    if (N < 0)
    {
    printf("  Sizes must be greater than 0.\n");
    exit(1);
    }
}

// 这模板外一堆加上参数传入过程，一眼丁真，遮沙避风了
template <typename crsMat_t>
void makeSparseMatrix(
    typename crsMat_t::StaticCrsGraphType::row_map_type::non_const_type &ptr,
    typename crsMat_t::StaticCrsGraphType::entries_type::non_const_type &ind,
    typename crsMat_t::values_type::non_const_type &val,
    typename crsMat_t::ordinal_type &numRows,
    typename crsMat_t::ordinal_type &numCols,
    typename crsMat_t::size_type &nnz,
    const int whichMatrix)
{
    // 此处解释一下CRS矩阵的基本构成，首先是row_map用于储存每一行上的第一个非零元的位置
    // 注意这里说的非零元的位置和下面的index都不是指的在稀疏矩阵(A(i,j))，而是在非零元数组
    // 中的位置，从0到N，就是稀疏模板
    typedef typename crsMat_t::StaticCrsGraphType::row_map_type::non_const_type ptr_type;
    // 其次需要包括一个在每列上非零元的位置，一般为index，或者entry(非零元入口)
    typedef typename crsMat_t::StaticCrsGraphType::entries_type::non_const_type ind_type;
    // 最后就是一个平平无奇的数组，从0开始到N结束，按照每一行进行记录每个非零元
    typedef typename crsMat_t::values_type::non_const_type val_type;
    // 这个就是index
    typedef typename crsMat_t::ordinal_type lno_t;
    // int
    typedef typename crsMat_t::size_type size_type;
    // 存储的数据类型
    typedef typename crsMat_t::value_type scalar_t;

    using Kokkos::HostSpace;
    using Kokkos::MemoryUnmanaged;
    using Kokkos::View;

    if (whichMatrix == 0)
    {
    // 这里按照行来填充一个矩阵，矩阵的主对角线为2，主对角线两侧的对角线为-1
    // 其余为0的一个方阵
    numCols = numRows;
    // 非零元的个数
    nnz = 2 + 3 * (numRows - 2) + 2;
    // 这里多声明一个位置是为了存储最大的列数量，用于提前给其他算法提供一个
    // 最大的内存分配大小
    size_type *ptrRaw = new size_type[numRows + 1];
    // 列索引向量
    lno_t *indRaw = new lno_t[nnz];
    // 非零元的值
    scalar_t *valRaw = new scalar_t[nnz];

    scalar_t two = 2.0;
    scalar_t mone = -1.0;

    // Add rows one-at-a-time
    for (int i = 0; i < (numRows + 1); i++)
    {
        // [2, -1, ... ,0]
        if (i == 0)
        {
        ptrRaw[0] = 0;
        indRaw[0] = 0;
        indRaw[1] = 1;
        valRaw[0] = two;
        valRaw[1] = mone;
        }
        else if (i == numRows)
        {
        ptrRaw[numRows] = nnz;
        }
        // [0, ... , -1, 2]
        else if (i == (numRows - 1))
        {
        ptrRaw[i] = 2 + 3 * (i - 1);
        indRaw[2 + 3 * (i - 1)] = i - 1;
        indRaw[2 + 3 * (i - 1) + 1] = i;
        valRaw[2 + 3 * (i - 1)] = mone;
        valRaw[2 + 3 * (i - 1) + 1] = two;
        }
        // [0, ... , -1, 2, -1, ... , 0]
        else
        {
        ptrRaw[i] = 2 + 3 * (i - 1);
        indRaw[2 + 3 * (i - 1)] = i - 1;
        indRaw[2 + 3 * (i - 1) + 1] = i;
        indRaw[2 + 3 * (i - 1) + 2] = i + 1;
        valRaw[2 + 3 * (i - 1)] = mone;
        valRaw[2 + 3 * (i - 1) + 1] = two;
        valRaw[2 + 3 * (i - 1) + 2] = mone;
        }
    }

    // 用填充好的三个向量初始Kokkos::View
    // 创建View
    ptr = ptr_type("ptr", numRows + 1);
    ind = ind_type("ind", nnz);
    val = val_type("val", nnz);

    // 用HostMirror将之前填充好的内容进行封装
    typename ptr_type::HostMirror::const_type ptrIn(ptrRaw, numRows + 1);
    typename ind_type::HostMirror::const_type indIn(indRaw, nnz);
    typename val_type::HostMirror::const_type valIn(valRaw, nnz);

    // 转移到View上
    Kokkos::deep_copy(ptr, ptrIn);
    Kokkos::deep_copy(ind, indIn);
    Kokkos::deep_copy(val, valIn);

    delete[] ptrRaw;
    delete[] indRaw;
    delete[] valRaw;
    }
    else
    { // whichMatrix != 0
    std::ostringstream os;
    os << "Invalid whichMatrix value " << whichMatrix
        << ".  Valid value(s) include " << 0 << ".";
    throw std::invalid_argument(os.str());
    }
}

template <typename crsMat_t>
crsMat_t makeCrsMatrix(int numRows)
{
    typedef typename crsMat_t::StaticCrsGraphType graph_t;
    typedef typename graph_t::row_map_type::non_const_type lno_view_t;
    typedef typename graph_t::entries_type::non_const_type lno_nnz_view_t;
    typedef typename crsMat_t::values_type::non_const_type scalar_view_t;
    typedef typename crsMat_t::ordinal_type lno_t;
    typedef typename crsMat_t::size_type size_type;

    lno_view_t ptr;
    lno_nnz_view_t ind;
    scalar_view_t val;
    lno_t numCols;
    size_type nnz;

    const int whichMatrix = 0;
    makeSparseMatrix<crsMat_t>(ptr, ind, val, numRows, numCols, nnz, whichMatrix);
    // 使用填充好的View对矩阵进行初始化
    return crsMat_t("A", numRows, numCols, nnz, val, ptr, ind);
}

int main(int argc, char *argv[])
{
    // Use current time as seed for random generator
    srand(time(0)); 

    int N = -1; // number of rows 2^10

    // Read command line arguments.
    for (int i = 0; i < argc; i++)
    {
    if (strcmp(argv[i], "-N") == 0)
    {
        N = atoi(argv[++i]);
        printf("  User N is %d\n", N);
    }
    else if ((strcmp(argv[i], "-h") == 0) || (strcmp(argv[i], "-help") == 0))
    {
        printf("  SpGEMM (C=A*A) Options:\n");
        printf("  -N <int>:      determines number of rows (columns) (default: 2^10 = 1024)\n");
        printf("  -help (-h):            print this message\n\n");
        exit(1);
    }
    }

    // Check sizes.
    checkSizes(N);

    Kokkos::initialize(argc, argv);
    {
    // Typedefs
    typedef double scalar_type;
    typedef int ordinal_type;
    typedef int size_type;
    typedef Kokkos::DefaultExecutionSpace device_type;
    typedef KokkosSparse::CrsMatrix<scalar_type, ordinal_type, device_type, void, size_type> crs_matrix_type;

    // 创建稀疏矩阵A
    crs_matrix_type A = makeCrsMatrix<crs_matrix_type>(N);

    // 这东西是sandia的人写的，如果之前有用过Trilinos的可以直接把这个看成一个ParameterList
    typedef KokkosKernels::Experimental::KokkosKernelsHandle<size_type, ordinal_type, scalar_type,
                                                                typename device_type::execution_space, 
                                                                typename device_type::memory_space, 
                                                                typename device_type::memory_space>
        KernelHandle;

    KernelHandle kh;

    // Set parameters in the handle
    kh.set_team_work_size(16);
    kh.set_dynamic_scheduling(true);
    // kh.set_verbose(true);

    // 指定gemm的具体实现方式
    std::string myalg("SPGEMM_KK_MEMORY");
    KokkosSparse::SPGEMMAlgorithm spgemm_algorithm = KokkosSparse::StringToSPGEMMAlgorithm(myalg);
    // 创建这个指定的gemm计算器
    kh.create_spgemm_handle(spgemm_algorithm);

    crs_matrix_type C;

    Kokkos::Timer timer;

    // 大型稀疏矩阵的计算和求解基本分为两个部分，symbolic和numeric
    // symbolic可以认为是进行分析步，前处理
    // numeric是真正意义上在进行计算
    // C = A * A
    KokkosSparse::spgemm_symbolic(kh, A, false, A, false, C);

    Kokkos::fence();
    double symbolic_time = timer.seconds();
    timer.reset();
    // EXERCISE: Call the numeric phase
    // EXERCISE hint: KokkosSparse::spgemm_numeric(...)
    KokkosSparse::spgemm_numeric(kh, A, false, A, false, C);

    Kokkos::fence();
    double numeric_time = timer.seconds();

    // Destroy the SpGEMM handle
    kh.destroy_spgemm_handle();

    // Print results (problem size, time, number of iterations and final norm residual).
    printf("    Results: N( %d ), overall spgemm time( %g s ), symbolic time( %g s ), numeric time( %g s )\n",
            N, symbolic_time + numeric_time, symbolic_time, numeric_time);
    }

    Kokkos::finalize();

    return 0;
}
\end{lstlisting}